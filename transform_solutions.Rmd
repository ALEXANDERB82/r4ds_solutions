---
title: "transform_solutions"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(nycflights13)
library(ggplot2)
```
# look at flights data
flights 

# 4.2.4
### 1. Find all flights that
#### 1.1. Had an arrival delay of two or more hours.
```{r}
filter(flights, arr_delay>=120)
```

#### 1.2. Flew to Houston (`IAH` or `HOU`)
```{r}
filter(flights, dest == 'IAH' | dest == 'HOU')
filter(flights, dest %in% c('IAH', 'HOU'))
```

#### 1.3. Were operated by United, American, or Delta
```{r}
filter(flights, carrier == 'UA' | carrier == 'AA' | carrier == 'DL')
filter(flights, carrier %in% c('UA', 'AA', 'DL'))
```

#### 1.4. Departed in summer (July, August, and September)
```{r}
filter(flights, month <= 7, month <= 9)
filter(flights, month <= 7 & month <= 9)

```

#### 1.5. Arrived more than two hours late, but didn't leave late
```{r}
filter(flights, arr_delay > 120, dep_delay <= 0)
```

#### 1.6. Were delayed by at least an hour, but made up over 30 minutes in flight
```{r}
filter(flights, dep_delay >= 60, dep_delay-arr_delay > 30)
```

#### 1.7. Departed between midnight and 6am (inclusive)
```{r}
filter(flights, dep_time <=600 | dep_time == 2400)
```

### 2. Another useful dplyr filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?
Between is a shorter, faster way of testing two inequalities at once: it tests if its first argument is greater than or equal to its second, and less than or equal to its third.
```{r}
filter(flights, between(month, 7, 9))
filter(flights, !between(dep_time, 601, 2359))
```

### 3. How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?
```{r}
summary(flights)
```

8255 flights have a missing `dep_time`, 8255 have a missing `dep_delay`, 8713 have a missing `arr_time`, 9430 have a missing `arr_delay`, and 9430 have a missing `air_time`. We can speculate that these are flights that failed to depart or arrive, since a flight that departs normally but is then rerouted will probably have a normally recorded departure but no similar record for it's arrival. However, these could also just be lost data about perfectly normal flights.

### 4. Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing? Why is `FALSE & NA` not missing? Can you figure out the general rule?  (`NA * 0` is a tricky counterexample!)
`NA ^ 0` evaluates to 1 because anything to the power of 0 is 1, so although we didn't know the original value, we know it's being taken to the zeroth power. 

With `NA | TRUE`, since the `|` operator returns `TRUE` if either of the terms are true, the whole expression returns true because the right half returns true. This is easier to see in an expression like `NA | 5<10` (since 5 is indeed less than 10).

For the next example, we know that `&` returns TRUE when both terms are true. So, for example, `TRUE & TRUE` evaluates to `TRUE`. In `FALSE & NA`, one of the terms is false, so the expression evaluates to `FALSE`. As does something like `FALSE & TRUE`.

`NA * 0` could be argued to be because the NA could represent `Inf`, and `Inf * 0` is `NaN` (Not a Number), rather than `NA`. However, I suspect that these results are dictated as much by what answer is natural, quick and sensible in C as by mathematical edge cases.


# 4.3.1
### 1. How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).
```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, desc(is.na(x)))
arrange(df, -(is.na(x)))

```

### 2. Sort flights to find the most delayed flights. Find the flights that left earliest.
```{r}
arrange(flights, desc(dep_delay))
arrange(flights, dep_delay)

```

### 3. Sort flights to find the fastest flights.
```{r}
# Note - this is a bit tricky since the time stamps are just encoded as integers
# so if a flight left at midnight (i.e. dep_time=2400) and arrived at 00:54 (arr_time=54),
# it's hard to just do arr_time - dep_time to get the travel time (you get back -2346, which doesn't make sense). 
# Taking absolute values doesn't help either.
# A workaround solution is just to add 2400 if the travel time is ever negative.
# A better solution is to properly encode the times as timestamps
# note: we use the `mutate` function and the pipe character `%>%`, which haven't been introduced yet

flights %>% mutate(travel_time = ifelse((arr_time - dep_time < 0), 
                                        2400+(arr_time - dep_time),
                                        arr_time - dep_time)) %>% 
  arrange(travel_time) %>% select(arr_time, dep_time, travel_time)

# for demonstration purposes, the naive solution is
arrange(flights, (arr_time - dep_time))

```

### 4. Which flights travelled the longest? Which travelled the shortest?
```{r}
# note: the `%>% select(1:5, distance)` is just so we can see the distance column, 
# which otherwise gets pushed off the console screen
arrange(flights, desc(distance)) %>% select(1:5, distance)
arrange(flights, distance) %>% select(1:5, distance)

```

# 4.4.1
### 1. How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).
```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, desc(is.na(x)))
arrange(df, -(is.na(x)))

```

